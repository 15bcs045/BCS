
BCS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000053a  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  000005ae  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000012  00800060  00800060  000005ae  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000005ae  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000005e0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000040  00000000  00000000  0000061c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000009fe  00000000  00000000  0000065c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000693  00000000  00000000  0000105a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000693  00000000  00000000  000016ed  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000008c  00000000  00000000  00001d80  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00006ce0  00000000  00000000  00001e0c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000023d  00000000  00000000  00008aec  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000030  00000000  00000000  00008d29  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000021f  00000000  00000000  00008d59  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	a1 c0       	rjmp	.+322    	; 0x144 <__ctors_end>
   2:	00 00       	nop
   4:	af c0       	rjmp	.+350    	; 0x164 <__bad_interrupt>
   6:	00 00       	nop
   8:	ad c0       	rjmp	.+346    	; 0x164 <__bad_interrupt>
   a:	00 00       	nop
   c:	ab c0       	rjmp	.+342    	; 0x164 <__bad_interrupt>
   e:	00 00       	nop
  10:	a9 c0       	rjmp	.+338    	; 0x164 <__bad_interrupt>
  12:	00 00       	nop
  14:	a7 c0       	rjmp	.+334    	; 0x164 <__bad_interrupt>
  16:	00 00       	nop
  18:	a5 c0       	rjmp	.+330    	; 0x164 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	a3 c0       	rjmp	.+326    	; 0x164 <__bad_interrupt>
  1e:	00 00       	nop
  20:	a1 c0       	rjmp	.+322    	; 0x164 <__bad_interrupt>
  22:	00 00       	nop
  24:	9f c0       	rjmp	.+318    	; 0x164 <__bad_interrupt>
  26:	00 00       	nop
  28:	9d c0       	rjmp	.+314    	; 0x164 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	9b c0       	rjmp	.+310    	; 0x164 <__bad_interrupt>
  2e:	00 00       	nop
  30:	99 c0       	rjmp	.+306    	; 0x164 <__bad_interrupt>
  32:	00 00       	nop
  34:	97 c0       	rjmp	.+302    	; 0x164 <__bad_interrupt>
  36:	00 00       	nop
  38:	95 c0       	rjmp	.+298    	; 0x164 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	93 c0       	rjmp	.+294    	; 0x164 <__bad_interrupt>
  3e:	00 00       	nop
  40:	91 c0       	rjmp	.+290    	; 0x164 <__bad_interrupt>
  42:	00 00       	nop
  44:	8f c0       	rjmp	.+286    	; 0x164 <__bad_interrupt>
  46:	00 00       	nop
  48:	8d c0       	rjmp	.+282    	; 0x164 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	8b c0       	rjmp	.+278    	; 0x164 <__bad_interrupt>
  4e:	00 00       	nop
  50:	89 c0       	rjmp	.+274    	; 0x164 <__bad_interrupt>
  52:	00 00       	nop
  54:	18 01       	movw	r2, r16
  56:	e8 00       	.word	0x00e8	; ????
  58:	8b 01       	movw	r16, r22
  5a:	f8 00       	.word	0x00f8	; ????
  5c:	8b 01       	movw	r16, r22
  5e:	8b 01       	movw	r16, r22
  60:	8b 01       	movw	r16, r22
  62:	08 01       	movw	r0, r16
  64:	8b 01       	movw	r16, r22
  66:	8b 01       	movw	r16, r22
  68:	8b 01       	movw	r16, r22
  6a:	8b 01       	movw	r16, r22
  6c:	8b 01       	movw	r16, r22
  6e:	8b 01       	movw	r16, r22
  70:	8b 01       	movw	r16, r22
  72:	8b 01       	movw	r16, r22
  74:	58 01       	movw	r10, r16
  76:	28 01       	movw	r4, r16
  78:	8b 01       	movw	r16, r22
  7a:	38 01       	movw	r6, r16
  7c:	8b 01       	movw	r16, r22
  7e:	8b 01       	movw	r16, r22
  80:	8b 01       	movw	r16, r22
  82:	48 01       	movw	r8, r16
  84:	8b 01       	movw	r16, r22
  86:	8b 01       	movw	r16, r22
  88:	8b 01       	movw	r16, r22
  8a:	8b 01       	movw	r16, r22
  8c:	8b 01       	movw	r16, r22
  8e:	8b 01       	movw	r16, r22
  90:	8b 01       	movw	r16, r22
  92:	8b 01       	movw	r16, r22
  94:	8b 01       	movw	r16, r22
  96:	8b 01       	movw	r16, r22
  98:	8b 01       	movw	r16, r22
  9a:	8b 01       	movw	r16, r22
  9c:	8b 01       	movw	r16, r22
  9e:	8b 01       	movw	r16, r22
  a0:	8b 01       	movw	r16, r22
  a2:	8b 01       	movw	r16, r22
  a4:	8b 01       	movw	r16, r22
  a6:	8b 01       	movw	r16, r22
  a8:	8b 01       	movw	r16, r22
  aa:	8b 01       	movw	r16, r22
  ac:	8b 01       	movw	r16, r22
  ae:	8b 01       	movw	r16, r22
  b0:	8b 01       	movw	r16, r22
  b2:	8b 01       	movw	r16, r22
  b4:	77 01       	movw	r14, r14
  b6:	db 00       	.word	0x00db	; ????
  b8:	8b 01       	movw	r16, r22
  ba:	d2 00       	.word	0x00d2	; ????
  bc:	8b 01       	movw	r16, r22
  be:	8b 01       	movw	r16, r22
  c0:	8b 01       	movw	r16, r22
  c2:	e3 00       	.word	0x00e3	; ????
  c4:	8b 01       	movw	r16, r22
  c6:	8b 01       	movw	r16, r22
  c8:	8b 01       	movw	r16, r22
  ca:	8b 01       	movw	r16, r22
  cc:	8b 01       	movw	r16, r22
  ce:	8b 01       	movw	r16, r22
  d0:	8b 01       	movw	r16, r22
  d2:	8b 01       	movw	r16, r22
  d4:	8b 01       	movw	r16, r22
  d6:	8b 01       	movw	r16, r22
  d8:	8b 01       	movw	r16, r22
  da:	8b 01       	movw	r16, r22
  dc:	8b 01       	movw	r16, r22
  de:	8b 01       	movw	r16, r22
  e0:	8b 01       	movw	r16, r22
  e2:	8b 01       	movw	r16, r22
  e4:	8b 01       	movw	r16, r22
  e6:	8b 01       	movw	r16, r22
  e8:	8b 01       	movw	r16, r22
  ea:	8b 01       	movw	r16, r22
  ec:	8b 01       	movw	r16, r22
  ee:	8b 01       	movw	r16, r22
  f0:	8b 01       	movw	r16, r22
  f2:	8b 01       	movw	r16, r22
  f4:	8b 01       	movw	r16, r22
  f6:	8b 01       	movw	r16, r22
  f8:	8b 01       	movw	r16, r22
  fa:	8b 01       	movw	r16, r22
  fc:	8b 01       	movw	r16, r22
  fe:	8b 01       	movw	r16, r22
 100:	8b 01       	movw	r16, r22
 102:	8b 01       	movw	r16, r22
 104:	8b 01       	movw	r16, r22
 106:	8b 01       	movw	r16, r22
 108:	8b 01       	movw	r16, r22
 10a:	8b 01       	movw	r16, r22
 10c:	8b 01       	movw	r16, r22
 10e:	8b 01       	movw	r16, r22
 110:	8b 01       	movw	r16, r22
 112:	8b 01       	movw	r16, r22
 114:	8b 01       	movw	r16, r22
 116:	8b 01       	movw	r16, r22
 118:	8b 01       	movw	r16, r22
 11a:	8b 01       	movw	r16, r22
 11c:	8b 01       	movw	r16, r22
 11e:	8b 01       	movw	r16, r22
 120:	8b 01       	movw	r16, r22
 122:	8b 01       	movw	r16, r22
 124:	8b 01       	movw	r16, r22
 126:	8b 01       	movw	r16, r22
 128:	8b 01       	movw	r16, r22
 12a:	8b 01       	movw	r16, r22
 12c:	8b 01       	movw	r16, r22
 12e:	8b 01       	movw	r16, r22
 130:	8b 01       	movw	r16, r22
 132:	8b 01       	movw	r16, r22
 134:	68 01       	movw	r12, r16
 136:	c5 00       	.word	0x00c5	; ????
 138:	8b 01       	movw	r16, r22
 13a:	bc 00       	.word	0x00bc	; ????
 13c:	8b 01       	movw	r16, r22
 13e:	8b 01       	movw	r16, r22
 140:	8b 01       	movw	r16, r22
 142:	cd 00       	.word	0x00cd	; ????

00000144 <__ctors_end>:
 144:	11 24       	eor	r1, r1
 146:	1f be       	out	0x3f, r1	; 63
 148:	cf e5       	ldi	r28, 0x5F	; 95
 14a:	d4 e0       	ldi	r29, 0x04	; 4
 14c:	de bf       	out	0x3e, r29	; 62
 14e:	cd bf       	out	0x3d, r28	; 61

00000150 <__do_clear_bss>:
 150:	20 e0       	ldi	r18, 0x00	; 0
 152:	a0 e6       	ldi	r26, 0x60	; 96
 154:	b0 e0       	ldi	r27, 0x00	; 0
 156:	01 c0       	rjmp	.+2      	; 0x15a <.do_clear_bss_start>

00000158 <.do_clear_bss_loop>:
 158:	1d 92       	st	X+, r1

0000015a <.do_clear_bss_start>:
 15a:	a2 37       	cpi	r26, 0x72	; 114
 15c:	b2 07       	cpc	r27, r18
 15e:	e1 f7       	brne	.-8      	; 0x158 <.do_clear_bss_loop>
 160:	7a d1       	rcall	.+756    	; 0x456 <main>
 162:	e9 c1       	rjmp	.+978    	; 0x536 <_exit>

00000164 <__bad_interrupt>:
 164:	4d cf       	rjmp	.-358    	; 0x0 <__vectors>

00000166 <keyData>:
  }
 }

void keyData(int keyInput){//function for determining what each button does

   switch (keyInput){
 166:	41 97       	sbiw	r24, 0x11	; 17
 168:	88 37       	cpi	r24, 0x78	; 120
 16a:	91 05       	cpc	r25, r1
 16c:	08 f0       	brcs	.+2      	; 0x170 <keyData+0xa>
 16e:	d3 c0       	rjmp	.+422    	; 0x316 <keyData+0x1b0>
 170:	86 5d       	subi	r24, 0xD6	; 214
 172:	9f 4f       	sbci	r25, 0xFF	; 255
 174:	fc 01       	movw	r30, r24
 176:	d9 c1       	rjmp	.+946    	; 0x52a <__tablejump2__>

    case 0b10000100:// first input row "1"
	 word_1 = word_1 << 1;
 178:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <word_1>
 17c:	88 0f       	add	r24, r24
	 word_1 = word_1 | 0x01;
 17e:	81 60       	ori	r24, 0x01	; 1
 180:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <word_1>
	 matrix_data[3] = word_1;
 184:	80 93 65 00 	sts	0x0065, r24	; 0x800065 <matrix_data+0x3>
	 break;
 188:	08 95       	ret
    case 0b10000010://first input row "0"
	 word_1 = word_1 << 1;
 18a:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <word_1>
 18e:	88 0f       	add	r24, r24
 190:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <word_1>
	 matrix_data[3] = word_1;
 194:	80 93 65 00 	sts	0x0065, r24	; 0x800065 <matrix_data+0x3>
     break;
 198:	08 95       	ret
    case 0b10001000://first input row "DEL"
	 word_1 = 0;
 19a:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <word_1>
	 matrix_data[3] = word_1;
 19e:	10 92 65 00 	sts	0x0065, r1	; 0x800065 <matrix_data+0x3>
	 break;
 1a2:	08 95       	ret
    case 0b01000100://second input row "1"
	 word_2 = word_2 << 1;
 1a4:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <_edata>
 1a8:	88 0f       	add	r24, r24
	 word_2 = word_2 | 0x01;
 1aa:	81 60       	ori	r24, 0x01	; 1
 1ac:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <_edata>
	 matrix_data[2] = word_2;
 1b0:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <matrix_data+0x2>
	 break;
 1b4:	08 95       	ret
    case 0b01000010://second input row "0"
	 word_2 =  word_2<<1;
 1b6:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <_edata>
 1ba:	88 0f       	add	r24, r24
 1bc:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <_edata>
	 matrix_data[2] = word_2;
 1c0:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <matrix_data+0x2>
	 break;
 1c4:	08 95       	ret
    case 0b01001000://second input row "DEL"
	 word_2 = 0;
 1c6:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <_edata>
	 matrix_data[2] = word_2;
 1ca:	10 92 64 00 	sts	0x0064, r1	; 0x800064 <matrix_data+0x2>
	 break;
 1ce:	08 95       	ret
    case 0b00010010://multiplication
	 resulte = word_1 * word_2;
 1d0:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <word_1>
 1d4:	90 91 60 00 	lds	r25, 0x0060	; 0x800060 <_edata>
 1d8:	89 9f       	mul	r24, r25
 1da:	c0 01       	movw	r24, r0
 1dc:	11 24       	eor	r1, r1
 1de:	90 93 6d 00 	sts	0x006D, r25	; 0x80006d <resulte+0x1>
 1e2:	80 93 6c 00 	sts	0x006C, r24	; 0x80006c <resulte>
	 matrix_data[1] = resulte & 0x00FF;
 1e6:	e2 e6       	ldi	r30, 0x62	; 98
 1e8:	f0 e0       	ldi	r31, 0x00	; 0
 1ea:	81 83       	std	Z+1, r24	; 0x01
	 matrix_data[0] = (resulte >> 8) & 0x00FF;
 1ec:	90 83       	st	Z, r25
	 break;
 1ee:	08 95       	ret
    case 0b00010100://subtraction
	 resulte = word_1 - word_2;
 1f0:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <word_1>
 1f4:	90 e0       	ldi	r25, 0x00	; 0
 1f6:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <_edata>
 1fa:	82 1b       	sub	r24, r18
 1fc:	91 09       	sbc	r25, r1
 1fe:	90 93 6d 00 	sts	0x006D, r25	; 0x80006d <resulte+0x1>
 202:	80 93 6c 00 	sts	0x006C, r24	; 0x80006c <resulte>
     matrix_data[1] = resulte & 0x00FF;
 206:	e2 e6       	ldi	r30, 0x62	; 98
 208:	f0 e0       	ldi	r31, 0x00	; 0
 20a:	81 83       	std	Z+1, r24	; 0x01
	 matrix_data[0] = (resulte >> 8) & 0x00FF;
 20c:	90 83       	st	Z, r25
	 break;
 20e:	08 95       	ret
    case 0b00011000://division
	 resulte = word_1 / word_2;
 210:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <word_1>
 214:	60 91 60 00 	lds	r22, 0x0060	; 0x800060 <_edata>
 218:	7c d1       	rcall	.+760    	; 0x512 <__udivmodqi4>
 21a:	28 2f       	mov	r18, r24
 21c:	30 e0       	ldi	r19, 0x00	; 0
 21e:	30 93 6d 00 	sts	0x006D, r19	; 0x80006d <resulte+0x1>
 222:	20 93 6c 00 	sts	0x006C, r18	; 0x80006c <resulte>
	 matrix_data[1] = resulte & 0x00FF;
 226:	e2 e6       	ldi	r30, 0x62	; 98
 228:	f0 e0       	ldi	r31, 0x00	; 0
 22a:	81 83       	std	Z+1, r24	; 0x01
	 matrix_data[0] = (resulte >> 8) & 0x00FF;
 22c:	10 82       	st	Z, r1
	 break;
 22e:	08 95       	ret
    case 0b00010001://addition
	 resulte = word_1 + word_2;
 230:	20 91 61 00 	lds	r18, 0x0061	; 0x800061 <word_1>
 234:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <_edata>
 238:	90 e0       	ldi	r25, 0x00	; 0
 23a:	82 0f       	add	r24, r18
 23c:	91 1d       	adc	r25, r1
 23e:	90 93 6d 00 	sts	0x006D, r25	; 0x80006d <resulte+0x1>
 242:	80 93 6c 00 	sts	0x006C, r24	; 0x80006c <resulte>
	 matrix_data[1] = resulte & 0x00FF;
 246:	e2 e6       	ldi	r30, 0x62	; 98
 248:	f0 e0       	ldi	r31, 0x00	; 0
 24a:	81 83       	std	Z+1, r24	; 0x01
	 matrix_data[0] = (resulte >> 8) & 0x00FF;
 24c:	90 83       	st	Z, r25
	 break;
 24e:	08 95       	ret
    case 0b00100010://modulo
	 resulte = word_1 % word_2;
 250:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <word_1>
 254:	60 91 60 00 	lds	r22, 0x0060	; 0x800060 <_edata>
 258:	5c d1       	rcall	.+696    	; 0x512 <__udivmodqi4>
 25a:	29 2f       	mov	r18, r25
 25c:	30 e0       	ldi	r19, 0x00	; 0
 25e:	30 93 6d 00 	sts	0x006D, r19	; 0x80006d <resulte+0x1>
 262:	20 93 6c 00 	sts	0x006C, r18	; 0x80006c <resulte>
	 matrix_data[1] = resulte & 0x00FF;
 266:	e2 e6       	ldi	r30, 0x62	; 98
 268:	f0 e0       	ldi	r31, 0x00	; 0
 26a:	91 83       	std	Z+1, r25	; 0x01
	 matrix_data[0] = (resulte >> 8) & 0x00FF;
 26c:	10 82       	st	Z, r1
     break;
 26e:	08 95       	ret
    case 0b00100100://XOR
	 resulte = word_1 ^ word_2;
 270:	90 91 60 00 	lds	r25, 0x0060	; 0x800060 <_edata>
 274:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <word_1>
 278:	89 27       	eor	r24, r25
 27a:	28 2f       	mov	r18, r24
 27c:	30 e0       	ldi	r19, 0x00	; 0
 27e:	30 93 6d 00 	sts	0x006D, r19	; 0x80006d <resulte+0x1>
 282:	20 93 6c 00 	sts	0x006C, r18	; 0x80006c <resulte>
	 matrix_data[1] = resulte & 0x00FF;
 286:	e2 e6       	ldi	r30, 0x62	; 98
 288:	f0 e0       	ldi	r31, 0x00	; 0
 28a:	81 83       	std	Z+1, r24	; 0x01
	 matrix_data[0] = (resulte >> 8) & 0x00FF;
 28c:	10 82       	st	Z, r1
	 break;
 28e:	08 95       	ret
    case 0b00101000://OR
	 resulte = word_1 | word_2;
 290:	90 91 60 00 	lds	r25, 0x0060	; 0x800060 <_edata>
 294:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <word_1>
 298:	89 2b       	or	r24, r25
 29a:	28 2f       	mov	r18, r24
 29c:	30 e0       	ldi	r19, 0x00	; 0
 29e:	30 93 6d 00 	sts	0x006D, r19	; 0x80006d <resulte+0x1>
 2a2:	20 93 6c 00 	sts	0x006C, r18	; 0x80006c <resulte>
	 matrix_data[1] = resulte & 0x00FF;
 2a6:	e2 e6       	ldi	r30, 0x62	; 98
 2a8:	f0 e0       	ldi	r31, 0x00	; 0
 2aa:	81 83       	std	Z+1, r24	; 0x01
	 matrix_data[0] = (resulte >> 8) & 0x00FF;
 2ac:	10 82       	st	Z, r1
	 break;
 2ae:	08 95       	ret
    case 0b00100001://AND
	 resulte = word_1 & word_2;
 2b0:	90 91 60 00 	lds	r25, 0x0060	; 0x800060 <_edata>
 2b4:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <word_1>
 2b8:	89 23       	and	r24, r25
 2ba:	28 2f       	mov	r18, r24
 2bc:	30 e0       	ldi	r19, 0x00	; 0
 2be:	30 93 6d 00 	sts	0x006D, r19	; 0x80006d <resulte+0x1>
 2c2:	20 93 6c 00 	sts	0x006C, r18	; 0x80006c <resulte>
	 matrix_data[1] = resulte & 0x00FF;
 2c6:	e2 e6       	ldi	r30, 0x62	; 98
 2c8:	f0 e0       	ldi	r31, 0x00	; 0
 2ca:	81 83       	std	Z+1, r24	; 0x01
	 matrix_data[0] = (resulte >> 8) & 0x00FF;
 2cc:	10 82       	st	Z, r1
	 break;
 2ce:	08 95       	ret
    case 0b10000001://NOT
	 resulte = ~resulte;
 2d0:	80 91 6c 00 	lds	r24, 0x006C	; 0x80006c <resulte>
 2d4:	90 91 6d 00 	lds	r25, 0x006D	; 0x80006d <resulte+0x1>
 2d8:	80 95       	com	r24
 2da:	90 95       	com	r25
 2dc:	90 93 6d 00 	sts	0x006D, r25	; 0x80006d <resulte+0x1>
 2e0:	80 93 6c 00 	sts	0x006C, r24	; 0x80006c <resulte>
	 matrix_data[1] = resulte & 0x00FF;
 2e4:	e2 e6       	ldi	r30, 0x62	; 98
 2e6:	f0 e0       	ldi	r31, 0x00	; 0
 2e8:	81 83       	std	Z+1, r24	; 0x01
	 matrix_data[0] = (resulte >> 8) & 0x00FF;
 2ea:	90 83       	st	Z, r25
	 break;
 2ec:	08 95       	ret
    case 0b01000001://DEL ALL
	 word_1 = 0;
 2ee:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <word_1>
	 word_2 = 0;
 2f2:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <_edata>
	 resulte =0;
 2f6:	10 92 6d 00 	sts	0x006D, r1	; 0x80006d <resulte+0x1>
 2fa:	10 92 6c 00 	sts	0x006C, r1	; 0x80006c <resulte>
	 for(reset_loop=0;reset_loop<4;reset_loop++)
	  matrix_data[reset_loop] = 0;
 2fe:	e2 e6       	ldi	r30, 0x62	; 98
 300:	f0 e0       	ldi	r31, 0x00	; 0
 302:	10 82       	st	Z, r1
 304:	11 82       	std	Z+1, r1	; 0x01
 306:	12 82       	std	Z+2, r1	; 0x02
 308:	13 82       	std	Z+3, r1	; 0x03
 30a:	84 e0       	ldi	r24, 0x04	; 4
 30c:	90 e0       	ldi	r25, 0x00	; 0
 30e:	90 93 6f 00 	sts	0x006F, r25	; 0x80006f <reset_loop+0x1>
 312:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <reset_loop>
 316:	08 95       	ret

00000318 <getKeyPress>:

/***************************************************************************************************************************************************************
                                                         Function definition begins
***************************************************************************************************************************************************************/

void getKeyPress(){ // checks what key is being pressed
 318:	0f 93       	push	r16
 31a:	1f 93       	push	r17
 31c:	cf 93       	push	r28
 31e:	df 93       	push	r29
     for(keyRow=0;keyRow<4;keyRow++){ // scans the switch matrix(4 rows)
 320:	10 92 69 00 	sts	0x0069, r1	; 0x800069 <keyRow+0x1>
 324:	10 92 68 00 	sts	0x0068, r1	; 0x800068 <keyRow>
 328:	80 e0       	ldi	r24, 0x00	; 0
 32a:	90 e0       	ldi	r25, 0x00	; 0
    PORTD = (1<<keyRow); // sends a HIGH to one row at a time
 32c:	01 e0       	ldi	r16, 0x01	; 1
 32e:	10 e0       	ldi	r17, 0x00	; 0
    columnData = (PIND & 0xF0);// reads the state of each column
	_delay_us(100);// a small delay
	if(columnData != 0){// if something is pressed columndata is bigger then zero
   	 keyData(columnData | (1<<keyRow));//goes to the data analysis function
 330:	c8 e6       	ldi	r28, 0x68	; 104
 332:	d0 e0       	ldi	r29, 0x00	; 0
                                                         Function definition begins
***************************************************************************************************************************************************************/

void getKeyPress(){ // checks what key is being pressed
     for(keyRow=0;keyRow<4;keyRow++){ // scans the switch matrix(4 rows)
    PORTD = (1<<keyRow); // sends a HIGH to one row at a time
 334:	98 01       	movw	r18, r16
 336:	02 c0       	rjmp	.+4      	; 0x33c <getKeyPress+0x24>
 338:	22 0f       	add	r18, r18
 33a:	33 1f       	adc	r19, r19
 33c:	8a 95       	dec	r24
 33e:	e2 f7       	brpl	.-8      	; 0x338 <getKeyPress+0x20>
 340:	22 bb       	out	0x12, r18	; 18
    columnData = (PIND & 0xF0);// reads the state of each column
 342:	80 b3       	in	r24, 0x10	; 16
 344:	80 7f       	andi	r24, 0xF0	; 240
 346:	90 e0       	ldi	r25, 0x00	; 0
 348:	90 93 71 00 	sts	0x0071, r25	; 0x800071 <columnData+0x1>
 34c:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <columnData>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 350:	87 ec       	ldi	r24, 0xC7	; 199
 352:	90 e0       	ldi	r25, 0x00	; 0
 354:	01 97       	sbiw	r24, 0x01	; 1
 356:	f1 f7       	brne	.-4      	; 0x354 <getKeyPress+0x3c>
 358:	00 c0       	rjmp	.+0      	; 0x35a <getKeyPress+0x42>
 35a:	00 00       	nop
	_delay_us(100);// a small delay
	if(columnData != 0){// if something is pressed columndata is bigger then zero
 35c:	80 91 70 00 	lds	r24, 0x0070	; 0x800070 <columnData>
 360:	90 91 71 00 	lds	r25, 0x0071	; 0x800071 <columnData+0x1>
 364:	00 97       	sbiw	r24, 0x00	; 0
 366:	81 f0       	breq	.+32     	; 0x388 <getKeyPress+0x70>
   	 keyData(columnData | (1<<keyRow));//goes to the data analysis function
 368:	98 01       	movw	r18, r16
 36a:	08 80       	ld	r0, Y
 36c:	02 c0       	rjmp	.+4      	; 0x372 <getKeyPress+0x5a>
 36e:	22 0f       	add	r18, r18
 370:	33 1f       	adc	r19, r19
 372:	0a 94       	dec	r0
 374:	e2 f7       	brpl	.-8      	; 0x36e <getKeyPress+0x56>
 376:	82 2b       	or	r24, r18
 378:	93 2b       	or	r25, r19
 37a:	f5 de       	rcall	.-534    	; 0x166 <keyData>
 37c:	8f e1       	ldi	r24, 0x1F	; 31
 37e:	93 e0       	ldi	r25, 0x03	; 3
 380:	01 97       	sbiw	r24, 0x01	; 1
 382:	f1 f7       	brne	.-4      	; 0x380 <getKeyPress+0x68>
 384:	00 c0       	rjmp	.+0      	; 0x386 <getKeyPress+0x6e>
 386:	00 00       	nop
/***************************************************************************************************************************************************************
                                                         Function definition begins
***************************************************************************************************************************************************************/

void getKeyPress(){ // checks what key is being pressed
     for(keyRow=0;keyRow<4;keyRow++){ // scans the switch matrix(4 rows)
 388:	80 91 68 00 	lds	r24, 0x0068	; 0x800068 <keyRow>
 38c:	90 91 69 00 	lds	r25, 0x0069	; 0x800069 <keyRow+0x1>
 390:	01 96       	adiw	r24, 0x01	; 1
 392:	90 93 69 00 	sts	0x0069, r25	; 0x800069 <keyRow+0x1>
 396:	80 93 68 00 	sts	0x0068, r24	; 0x800068 <keyRow>
 39a:	84 30       	cpi	r24, 0x04	; 4
 39c:	91 05       	cpc	r25, r1
 39e:	54 f2       	brlt	.-108    	; 0x334 <getKeyPress+0x1c>
	if(columnData != 0){// if something is pressed columndata is bigger then zero
   	 keyData(columnData | (1<<keyRow));//goes to the data analysis function
	 _delay_us(400);//a small delay like in the LED scanning loop
   }
  }
 }
 3a0:	df 91       	pop	r29
 3a2:	cf 91       	pop	r28
 3a4:	1f 91       	pop	r17
 3a6:	0f 91       	pop	r16
 3a8:	08 95       	ret

000003aa <pinMode>:
}


void pinMode(int position, int value)
{
        if (value == 0)
 3aa:	67 2b       	or	r22, r23
 3ac:	71 f4       	brne	.+28     	; 0x3ca <pinMode+0x20>
          PORTA &= ~(1 << position);
 3ae:	4b b3       	in	r20, 0x1b	; 27
 3b0:	21 e0       	ldi	r18, 0x01	; 1
 3b2:	30 e0       	ldi	r19, 0x00	; 0
 3b4:	b9 01       	movw	r22, r18
 3b6:	02 c0       	rjmp	.+4      	; 0x3bc <pinMode+0x12>
 3b8:	66 0f       	add	r22, r22
 3ba:	77 1f       	adc	r23, r23
 3bc:	8a 95       	dec	r24
 3be:	e2 f7       	brpl	.-8      	; 0x3b8 <pinMode+0xe>
 3c0:	cb 01       	movw	r24, r22
 3c2:	80 95       	com	r24
 3c4:	84 23       	and	r24, r20
 3c6:	8b bb       	out	0x1b, r24	; 27
 3c8:	08 95       	ret
        else
          PORTA |= (1 << position);
 3ca:	4b b3       	in	r20, 0x1b	; 27
 3cc:	21 e0       	ldi	r18, 0x01	; 1
 3ce:	30 e0       	ldi	r19, 0x00	; 0
 3d0:	b9 01       	movw	r22, r18
 3d2:	02 c0       	rjmp	.+4      	; 0x3d8 <pinMode+0x2e>
 3d4:	66 0f       	add	r22, r22
 3d6:	77 1f       	adc	r23, r23
 3d8:	8a 95       	dec	r24
 3da:	e2 f7       	brpl	.-8      	; 0x3d4 <pinMode+0x2a>
 3dc:	cb 01       	movw	r24, r22
 3de:	84 2b       	or	r24, r20
 3e0:	8b bb       	out	0x1b, r24	; 27
 3e2:	08 95       	ret

000003e4 <shiftout>:
	 break;
    }
   }


void shiftout(unsigned char myDataOut) { // the function for sending the data to the shift register
 3e4:	0f 93       	push	r16
 3e6:	1f 93       	push	r17
 3e8:	cf 93       	push	r28
 3ea:	df 93       	push	r29
 3ec:	08 2f       	mov	r16, r24
  int i;
  int pinState=0;
  pinMode(4,0);
 3ee:	60 e0       	ldi	r22, 0x00	; 0
 3f0:	70 e0       	ldi	r23, 0x00	; 0
 3f2:	84 e0       	ldi	r24, 0x04	; 4
 3f4:	90 e0       	ldi	r25, 0x00	; 0
 3f6:	d9 df       	rcall	.-78     	; 0x3aa <pinMode>
  pinMode(6,0);
 3f8:	60 e0       	ldi	r22, 0x00	; 0
 3fa:	70 e0       	ldi	r23, 0x00	; 0
 3fc:	86 e0       	ldi	r24, 0x06	; 6
 3fe:	90 e0       	ldi	r25, 0x00	; 0
 400:	d4 df       	rcall	.-88     	; 0x3aa <pinMode>
  for (i=7; i>=0; i--)  {
 402:	c7 e0       	ldi	r28, 0x07	; 7
 404:	d0 e0       	ldi	r29, 0x00	; 0
    pinMode(6,0);
    if ( myDataOut & (1<<i) )
 406:	10 e0       	ldi	r17, 0x00	; 0
  int i;
  int pinState=0;
  pinMode(4,0);
  pinMode(6,0);
  for (i=7; i>=0; i--)  {
    pinMode(6,0);
 408:	60 e0       	ldi	r22, 0x00	; 0
 40a:	70 e0       	ldi	r23, 0x00	; 0
 40c:	86 e0       	ldi	r24, 0x06	; 6
 40e:	90 e0       	ldi	r25, 0x00	; 0
 410:	cc df       	rcall	.-104    	; 0x3aa <pinMode>
    if ( myDataOut & (1<<i) )
 412:	b8 01       	movw	r22, r16
 414:	0c 2e       	mov	r0, r28
 416:	02 c0       	rjmp	.+4      	; 0x41c <__LOCK_REGION_LENGTH__+0x1c>
 418:	75 95       	asr	r23
 41a:	67 95       	ror	r22
 41c:	0a 94       	dec	r0
 41e:	e2 f7       	brpl	.-8      	; 0x418 <__LOCK_REGION_LENGTH__+0x18>
 420:	61 70       	andi	r22, 0x01	; 1
 422:	77 27       	eor	r23, r23
      pinState = 1;
    else
      pinState = 0;
    pinMode(4,pinState);
 424:	84 e0       	ldi	r24, 0x04	; 4
 426:	90 e0       	ldi	r25, 0x00	; 0
 428:	c0 df       	rcall	.-128    	; 0x3aa <pinMode>
    pinMode(6,1);
 42a:	61 e0       	ldi	r22, 0x01	; 1
 42c:	70 e0       	ldi	r23, 0x00	; 0
 42e:	86 e0       	ldi	r24, 0x06	; 6
 430:	90 e0       	ldi	r25, 0x00	; 0
 432:	bb df       	rcall	.-138    	; 0x3aa <pinMode>
    pinMode(4,0);
 434:	60 e0       	ldi	r22, 0x00	; 0
 436:	70 e0       	ldi	r23, 0x00	; 0
 438:	84 e0       	ldi	r24, 0x04	; 4
 43a:	90 e0       	ldi	r25, 0x00	; 0
 43c:	b6 df       	rcall	.-148    	; 0x3aa <pinMode>
void shiftout(unsigned char myDataOut) { // the function for sending the data to the shift register
  int i;
  int pinState=0;
  pinMode(4,0);
  pinMode(6,0);
  for (i=7; i>=0; i--)  {
 43e:	21 97       	sbiw	r28, 0x01	; 1
 440:	18 f7       	brcc	.-58     	; 0x408 <__LOCK_REGION_LENGTH__+0x8>
      pinState = 0;
    pinMode(4,pinState);
    pinMode(6,1);
    pinMode(4,0);
  }
  pinMode(6,0);
 442:	60 e0       	ldi	r22, 0x00	; 0
 444:	70 e0       	ldi	r23, 0x00	; 0
 446:	86 e0       	ldi	r24, 0x06	; 6
 448:	90 e0       	ldi	r25, 0x00	; 0
 44a:	af df       	rcall	.-162    	; 0x3aa <pinMode>
}
 44c:	df 91       	pop	r29
 44e:	cf 91       	pop	r28
 450:	1f 91       	pop	r17
 452:	0f 91       	pop	r16
 454:	08 95       	ret

00000456 <main>:
unsigned char word_1=0,word_2=0;
/***************************************************************************************************************************************************************
                                                            Global Variable declaration ends
***************************************************************************************************************************************************************/
int main(void){
 DDRA = 0x0F;//pins PD0-PD3 outputs and pins PD4-PD7 inputs
 456:	8f e0       	ldi	r24, 0x0F	; 15
 458:	8a bb       	out	0x1a, r24	; 26
 DDRD = 0xFF;//pins PA0-PA7 as input
 45a:	8f ef       	ldi	r24, 0xFF	; 255
 45c:	81 bb       	out	0x11, r24	; 17
  while(1){// keeps the program running all the time

   for(ledRow=0;ledRow<4;ledRow++){// this is the loop for scanning the LED display
	 time_to_check ++;//counts the time until the next key press check(to prevent flickering of the matrix)
	 PORTA = 1<<ledRow;//sets only one pin from PD0-PD3 HIGH
 45e:	c1 e0       	ldi	r28, 0x01	; 1
 460:	d0 e0       	ldi	r29, 0x00	; 0
 462:	0c 2f       	mov	r16, r28
 464:	1d 2f       	mov	r17, r29
int main(void){
 DDRA = 0x0F;//pins PD0-PD3 outputs and pins PD4-PD7 inputs
 DDRD = 0xFF;//pins PA0-PA7 as input
  while(1){// keeps the program running all the time

   for(ledRow=0;ledRow<4;ledRow++){// this is the loop for scanning the LED display
 466:	10 92 6b 00 	sts	0x006B, r1	; 0x80006b <ledRow+0x1>
 46a:	10 92 6a 00 	sts	0x006A, r1	; 0x80006a <ledRow>
 46e:	80 e0       	ldi	r24, 0x00	; 0
 470:	90 e0       	ldi	r25, 0x00	; 0
	 time_to_check ++;//counts the time until the next key press check(to prevent flickering of the matrix)
 472:	20 91 66 00 	lds	r18, 0x0066	; 0x800066 <time_to_check>
 476:	30 91 67 00 	lds	r19, 0x0067	; 0x800067 <time_to_check+0x1>
 47a:	2f 5f       	subi	r18, 0xFF	; 255
 47c:	3f 4f       	sbci	r19, 0xFF	; 255
 47e:	30 93 67 00 	sts	0x0067, r19	; 0x800067 <time_to_check+0x1>
 482:	20 93 66 00 	sts	0x0066, r18	; 0x800066 <time_to_check>
	 PORTA = 1<<ledRow;//sets only one pin from PD0-PD3 HIGH
 486:	9e 01       	movw	r18, r28
 488:	02 c0       	rjmp	.+4      	; 0x48e <__stack+0x2f>
 48a:	22 0f       	add	r18, r18
 48c:	33 1f       	adc	r19, r19
 48e:	8a 95       	dec	r24
 490:	e2 f7       	brpl	.-8      	; 0x48a <__stack+0x2b>
 492:	2b bb       	out	0x1b, r18	; 27
	 pinMode(5,0);//latch off
 494:	60 e0       	ldi	r22, 0x00	; 0
 496:	70 e0       	ldi	r23, 0x00	; 0
 498:	85 e0       	ldi	r24, 0x05	; 5
 49a:	90 e0       	ldi	r25, 0x00	; 0
 49c:	86 df       	rcall	.-244    	; 0x3aa <pinMode>
	 shiftout(matrix_data[ledRow]);//writes the data to the shift register
 49e:	e0 91 6a 00 	lds	r30, 0x006A	; 0x80006a <ledRow>
 4a2:	f0 91 6b 00 	lds	r31, 0x006B	; 0x80006b <ledRow+0x1>
 4a6:	ee 59       	subi	r30, 0x9E	; 158
 4a8:	ff 4f       	sbci	r31, 0xFF	; 255
 4aa:	80 81       	ld	r24, Z
 4ac:	9b df       	rcall	.-202    	; 0x3e4 <shiftout>
	 pinMode(5,1);//latch on
 4ae:	60 2f       	mov	r22, r16
 4b0:	71 2f       	mov	r23, r17
 4b2:	85 e0       	ldi	r24, 0x05	; 5
 4b4:	90 e0       	ldi	r25, 0x00	; 0
 4b6:	79 df       	rcall	.-270    	; 0x3aa <pinMode>
	 if(time_to_check == 125){//looks when the time is right to check for a key press
 4b8:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <time_to_check>
 4bc:	90 91 67 00 	lds	r25, 0x0067	; 0x800067 <time_to_check+0x1>
 4c0:	8d 37       	cpi	r24, 0x7D	; 125
 4c2:	91 05       	cpc	r25, r1
 4c4:	31 f4       	brne	.+12     	; 0x4d2 <__stack+0x73>
	  getKeyPress();// goes to the key press function
 4c6:	28 df       	rcall	.-432    	; 0x318 <getKeyPress>
	  time_to_check =0;//resets the "counter"
 4c8:	10 92 67 00 	sts	0x0067, r1	; 0x800067 <time_to_check+0x1>
 4cc:	10 92 66 00 	sts	0x0066, r1	; 0x800066 <time_to_check>
 4d0:	06 c0       	rjmp	.+12     	; 0x4de <__stack+0x7f>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 4d2:	8f ec       	ldi	r24, 0xCF	; 207
 4d4:	97 e0       	ldi	r25, 0x07	; 7
 4d6:	01 97       	sbiw	r24, 0x01	; 1
 4d8:	f1 f7       	brne	.-4      	; 0x4d6 <__stack+0x77>
 4da:	00 c0       	rjmp	.+0      	; 0x4dc <__stack+0x7d>
 4dc:	00 00       	nop
	  }
     else
	  _delay_ms(1);// a delay for each LED row
	 pinMode(5,0);//latch off
 4de:	60 e0       	ldi	r22, 0x00	; 0
 4e0:	70 e0       	ldi	r23, 0x00	; 0
 4e2:	85 e0       	ldi	r24, 0x05	; 5
 4e4:	90 e0       	ldi	r25, 0x00	; 0
 4e6:	61 df       	rcall	.-318    	; 0x3aa <pinMode>
	 shiftout(0x00);// sets the shift registers outputs to low
 4e8:	80 e0       	ldi	r24, 0x00	; 0
 4ea:	7c df       	rcall	.-264    	; 0x3e4 <shiftout>
	 pinMode(5,1);//latch on
 4ec:	60 2f       	mov	r22, r16
 4ee:	71 2f       	mov	r23, r17
 4f0:	85 e0       	ldi	r24, 0x05	; 5
 4f2:	90 e0       	ldi	r25, 0x00	; 0
 4f4:	5a df       	rcall	.-332    	; 0x3aa <pinMode>
int main(void){
 DDRA = 0x0F;//pins PD0-PD3 outputs and pins PD4-PD7 inputs
 DDRD = 0xFF;//pins PA0-PA7 as input
  while(1){// keeps the program running all the time

   for(ledRow=0;ledRow<4;ledRow++){// this is the loop for scanning the LED display
 4f6:	80 91 6a 00 	lds	r24, 0x006A	; 0x80006a <ledRow>
 4fa:	90 91 6b 00 	lds	r25, 0x006B	; 0x80006b <ledRow+0x1>
 4fe:	01 96       	adiw	r24, 0x01	; 1
 500:	90 93 6b 00 	sts	0x006B, r25	; 0x80006b <ledRow+0x1>
 504:	80 93 6a 00 	sts	0x006A, r24	; 0x80006a <ledRow>
 508:	84 30       	cpi	r24, 0x04	; 4
 50a:	91 05       	cpc	r25, r1
 50c:	0c f4       	brge	.+2      	; 0x510 <__stack+0xb1>
 50e:	b1 cf       	rjmp	.-158    	; 0x472 <__stack+0x13>
 510:	aa cf       	rjmp	.-172    	; 0x466 <__stack+0x7>

00000512 <__udivmodqi4>:
 512:	99 1b       	sub	r25, r25
 514:	79 e0       	ldi	r23, 0x09	; 9
 516:	04 c0       	rjmp	.+8      	; 0x520 <__udivmodqi4_ep>

00000518 <__udivmodqi4_loop>:
 518:	99 1f       	adc	r25, r25
 51a:	96 17       	cp	r25, r22
 51c:	08 f0       	brcs	.+2      	; 0x520 <__udivmodqi4_ep>
 51e:	96 1b       	sub	r25, r22

00000520 <__udivmodqi4_ep>:
 520:	88 1f       	adc	r24, r24
 522:	7a 95       	dec	r23
 524:	c9 f7       	brne	.-14     	; 0x518 <__udivmodqi4_loop>
 526:	80 95       	com	r24
 528:	08 95       	ret

0000052a <__tablejump2__>:
 52a:	ee 0f       	add	r30, r30
 52c:	ff 1f       	adc	r31, r31
 52e:	05 90       	lpm	r0, Z+
 530:	f4 91       	lpm	r31, Z
 532:	e0 2d       	mov	r30, r0
 534:	09 94       	ijmp

00000536 <_exit>:
 536:	f8 94       	cli

00000538 <__stop_program>:
 538:	ff cf       	rjmp	.-2      	; 0x538 <__stop_program>
