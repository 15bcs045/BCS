
BCS CODE.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000564  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  000005d8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000012  00800060  00800060  000005d8  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000005d8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000608  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000040  00000000  00000000  00000644  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000009fa  00000000  00000000  00000684  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000690  00000000  00000000  0000107e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000004ef  00000000  00000000  0000170e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000008c  00000000  00000000  00001c00  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000003ca  00000000  00000000  00001c8c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000023d  00000000  00000000  00002056  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000030  00000000  00000000  00002293  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 a2 00 	jmp	0x144	; 0x144 <__ctors_end>
   4:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
   8:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
   c:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
  10:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
  14:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
  18:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
  1c:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
  20:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
  24:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
  28:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
  2c:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
  30:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
  34:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
  38:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
  3c:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
  40:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
  44:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
  48:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
  4c:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
  50:	0c 94 b4 00 	jmp	0x168	; 0x168 <__bad_interrupt>
  54:	1d 01       	movw	r2, r26
  56:	ec 00       	.word	0x00ec	; ????
  58:	91 01       	movw	r18, r2
  5a:	fc 00       	.word	0x00fc	; ????
  5c:	91 01       	movw	r18, r2
  5e:	91 01       	movw	r18, r2
  60:	91 01       	movw	r18, r2
  62:	0c 01       	movw	r0, r24
  64:	91 01       	movw	r18, r2
  66:	91 01       	movw	r18, r2
  68:	91 01       	movw	r18, r2
  6a:	91 01       	movw	r18, r2
  6c:	91 01       	movw	r18, r2
  6e:	91 01       	movw	r18, r2
  70:	91 01       	movw	r18, r2
  72:	91 01       	movw	r18, r2
  74:	5e 01       	movw	r10, r28
  76:	2d 01       	movw	r4, r26
  78:	91 01       	movw	r18, r2
  7a:	3e 01       	movw	r6, r28
  7c:	91 01       	movw	r18, r2
  7e:	91 01       	movw	r18, r2
  80:	91 01       	movw	r18, r2
  82:	4e 01       	movw	r8, r28
  84:	91 01       	movw	r18, r2
  86:	91 01       	movw	r18, r2
  88:	91 01       	movw	r18, r2
  8a:	91 01       	movw	r18, r2
  8c:	91 01       	movw	r18, r2
  8e:	91 01       	movw	r18, r2
  90:	91 01       	movw	r18, r2
  92:	91 01       	movw	r18, r2
  94:	91 01       	movw	r18, r2
  96:	91 01       	movw	r18, r2
  98:	91 01       	movw	r18, r2
  9a:	91 01       	movw	r18, r2
  9c:	91 01       	movw	r18, r2
  9e:	91 01       	movw	r18, r2
  a0:	91 01       	movw	r18, r2
  a2:	91 01       	movw	r18, r2
  a4:	91 01       	movw	r18, r2
  a6:	91 01       	movw	r18, r2
  a8:	91 01       	movw	r18, r2
  aa:	91 01       	movw	r18, r2
  ac:	91 01       	movw	r18, r2
  ae:	91 01       	movw	r18, r2
  b0:	91 01       	movw	r18, r2
  b2:	91 01       	movw	r18, r2
  b4:	7d 01       	movw	r14, r26
  b6:	df 00       	.word	0x00df	; ????
  b8:	91 01       	movw	r18, r2
  ba:	d6 00       	.word	0x00d6	; ????
  bc:	91 01       	movw	r18, r2
  be:	91 01       	movw	r18, r2
  c0:	91 01       	movw	r18, r2
  c2:	e7 00       	.word	0x00e7	; ????
  c4:	91 01       	movw	r18, r2
  c6:	91 01       	movw	r18, r2
  c8:	91 01       	movw	r18, r2
  ca:	91 01       	movw	r18, r2
  cc:	91 01       	movw	r18, r2
  ce:	91 01       	movw	r18, r2
  d0:	91 01       	movw	r18, r2
  d2:	91 01       	movw	r18, r2
  d4:	91 01       	movw	r18, r2
  d6:	91 01       	movw	r18, r2
  d8:	91 01       	movw	r18, r2
  da:	91 01       	movw	r18, r2
  dc:	91 01       	movw	r18, r2
  de:	91 01       	movw	r18, r2
  e0:	91 01       	movw	r18, r2
  e2:	91 01       	movw	r18, r2
  e4:	91 01       	movw	r18, r2
  e6:	91 01       	movw	r18, r2
  e8:	91 01       	movw	r18, r2
  ea:	91 01       	movw	r18, r2
  ec:	91 01       	movw	r18, r2
  ee:	91 01       	movw	r18, r2
  f0:	91 01       	movw	r18, r2
  f2:	91 01       	movw	r18, r2
  f4:	91 01       	movw	r18, r2
  f6:	91 01       	movw	r18, r2
  f8:	91 01       	movw	r18, r2
  fa:	91 01       	movw	r18, r2
  fc:	91 01       	movw	r18, r2
  fe:	91 01       	movw	r18, r2
 100:	91 01       	movw	r18, r2
 102:	91 01       	movw	r18, r2
 104:	91 01       	movw	r18, r2
 106:	91 01       	movw	r18, r2
 108:	91 01       	movw	r18, r2
 10a:	91 01       	movw	r18, r2
 10c:	91 01       	movw	r18, r2
 10e:	91 01       	movw	r18, r2
 110:	91 01       	movw	r18, r2
 112:	91 01       	movw	r18, r2
 114:	91 01       	movw	r18, r2
 116:	91 01       	movw	r18, r2
 118:	91 01       	movw	r18, r2
 11a:	91 01       	movw	r18, r2
 11c:	91 01       	movw	r18, r2
 11e:	91 01       	movw	r18, r2
 120:	91 01       	movw	r18, r2
 122:	91 01       	movw	r18, r2
 124:	91 01       	movw	r18, r2
 126:	91 01       	movw	r18, r2
 128:	91 01       	movw	r18, r2
 12a:	91 01       	movw	r18, r2
 12c:	91 01       	movw	r18, r2
 12e:	91 01       	movw	r18, r2
 130:	91 01       	movw	r18, r2
 132:	91 01       	movw	r18, r2
 134:	6e 01       	movw	r12, r28
 136:	c9 00       	.word	0x00c9	; ????
 138:	91 01       	movw	r18, r2
 13a:	c0 00       	.word	0x00c0	; ????
 13c:	91 01       	movw	r18, r2
 13e:	91 01       	movw	r18, r2
 140:	91 01       	movw	r18, r2
 142:	d1 00       	.word	0x00d1	; ????

00000144 <__ctors_end>:
 144:	11 24       	eor	r1, r1
 146:	1f be       	out	0x3f, r1	; 63
 148:	cf e5       	ldi	r28, 0x5F	; 95
 14a:	d4 e0       	ldi	r29, 0x04	; 4
 14c:	de bf       	out	0x3e, r29	; 62
 14e:	cd bf       	out	0x3d, r28	; 61

00000150 <__do_clear_bss>:
 150:	20 e0       	ldi	r18, 0x00	; 0
 152:	a0 e6       	ldi	r26, 0x60	; 96
 154:	b0 e0       	ldi	r27, 0x00	; 0
 156:	01 c0       	rjmp	.+2      	; 0x15a <.do_clear_bss_start>

00000158 <.do_clear_bss_loop>:
 158:	1d 92       	st	X+, r1

0000015a <.do_clear_bss_start>:
 15a:	a2 37       	cpi	r26, 0x72	; 114
 15c:	b2 07       	cpc	r27, r18
 15e:	e1 f7       	brne	.-8      	; 0x158 <.do_clear_bss_loop>
 160:	0e 94 39 02 	call	0x472	; 0x472 <main>
 164:	0c 94 b0 02 	jmp	0x560	; 0x560 <_exit>

00000168 <__bad_interrupt>:
 168:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000016c <keyData>:
  }
 }

void keyData(int keyInput){//function for determining what each button does

   switch (keyInput){
 16c:	41 97       	sbiw	r24, 0x11	; 17
 16e:	88 37       	cpi	r24, 0x78	; 120
 170:	91 05       	cpc	r25, r1
 172:	08 f0       	brcs	.+2      	; 0x176 <keyData+0xa>
 174:	d6 c0       	rjmp	.+428    	; 0x322 <keyData+0x1b6>
 176:	86 5d       	subi	r24, 0xD6	; 214
 178:	9f 4f       	sbci	r25, 0xFF	; 255
 17a:	fc 01       	movw	r30, r24
 17c:	0c 94 aa 02 	jmp	0x554	; 0x554 <__tablejump2__>

    case 0b10000100:// first input row "1"
	 word_1 = word_1 << 1;
 180:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <word_1>
 184:	88 0f       	add	r24, r24
	 word_1 = word_1 | 0x01;
 186:	81 60       	ori	r24, 0x01	; 1
 188:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <word_1>
	 matrix_data[3] = word_1;
 18c:	80 93 65 00 	sts	0x0065, r24	; 0x800065 <matrix_data+0x3>
	 break;
 190:	08 95       	ret
    case 0b10000010://first input row "0"
	 word_1 = word_1 << 1;
 192:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <word_1>
 196:	88 0f       	add	r24, r24
 198:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <word_1>
	 matrix_data[3] = word_1;
 19c:	80 93 65 00 	sts	0x0065, r24	; 0x800065 <matrix_data+0x3>
     break;
 1a0:	08 95       	ret
    case 0b10001000://first input row "DEL"
	 word_1 = 0;
 1a2:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <word_1>
	 matrix_data[3] = word_1;
 1a6:	10 92 65 00 	sts	0x0065, r1	; 0x800065 <matrix_data+0x3>
	 break;
 1aa:	08 95       	ret
    case 0b01000100://second input row "1"
	 word_2 = word_2 << 1;
 1ac:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <_edata>
 1b0:	88 0f       	add	r24, r24
	 word_2 = word_2 | 0x01;
 1b2:	81 60       	ori	r24, 0x01	; 1
 1b4:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <_edata>
	 matrix_data[2] = word_2;
 1b8:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <matrix_data+0x2>
	 break;
 1bc:	08 95       	ret
    case 0b01000010://second input row "0"
	 word_2 =  word_2<<1;
 1be:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <_edata>
 1c2:	88 0f       	add	r24, r24
 1c4:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <_edata>
	 matrix_data[2] = word_2;
 1c8:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <matrix_data+0x2>
	 break;
 1cc:	08 95       	ret
    case 0b01001000://second input row "DEL"
	 word_2 = 0;
 1ce:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <_edata>
	 matrix_data[2] = word_2;
 1d2:	10 92 64 00 	sts	0x0064, r1	; 0x800064 <matrix_data+0x2>
	 break;
 1d6:	08 95       	ret
    case 0b00010010://multiplication
	 resulte = word_1 * word_2;
 1d8:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <word_1>
 1dc:	90 91 60 00 	lds	r25, 0x0060	; 0x800060 <_edata>
 1e0:	89 9f       	mul	r24, r25
 1e2:	c0 01       	movw	r24, r0
 1e4:	11 24       	eor	r1, r1
 1e6:	90 93 6d 00 	sts	0x006D, r25	; 0x80006d <resulte+0x1>
 1ea:	80 93 6c 00 	sts	0x006C, r24	; 0x80006c <resulte>
	 matrix_data[1] = resulte & 0x00FF;
 1ee:	e2 e6       	ldi	r30, 0x62	; 98
 1f0:	f0 e0       	ldi	r31, 0x00	; 0
 1f2:	81 83       	std	Z+1, r24	; 0x01
	 matrix_data[0] = (resulte >> 8) & 0x00FF;
 1f4:	90 83       	st	Z, r25
	 break;
 1f6:	08 95       	ret
    case 0b00010100://subtraction
	 resulte = word_1 - word_2;
 1f8:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <word_1>
 1fc:	90 e0       	ldi	r25, 0x00	; 0
 1fe:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <_edata>
 202:	82 1b       	sub	r24, r18
 204:	91 09       	sbc	r25, r1
 206:	90 93 6d 00 	sts	0x006D, r25	; 0x80006d <resulte+0x1>
 20a:	80 93 6c 00 	sts	0x006C, r24	; 0x80006c <resulte>
     matrix_data[1] = resulte & 0x00FF;
 20e:	e2 e6       	ldi	r30, 0x62	; 98
 210:	f0 e0       	ldi	r31, 0x00	; 0
 212:	81 83       	std	Z+1, r24	; 0x01
	 matrix_data[0] = (resulte >> 8) & 0x00FF;
 214:	90 83       	st	Z, r25
	 break;
 216:	08 95       	ret
    case 0b00011000://division
	 resulte = word_1 / word_2;
 218:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <word_1>
 21c:	60 91 60 00 	lds	r22, 0x0060	; 0x800060 <_edata>
 220:	0e 94 9e 02 	call	0x53c	; 0x53c <__udivmodqi4>
 224:	28 2f       	mov	r18, r24
 226:	30 e0       	ldi	r19, 0x00	; 0
 228:	30 93 6d 00 	sts	0x006D, r19	; 0x80006d <resulte+0x1>
 22c:	20 93 6c 00 	sts	0x006C, r18	; 0x80006c <resulte>
	 matrix_data[1] = resulte & 0x00FF;
 230:	e2 e6       	ldi	r30, 0x62	; 98
 232:	f0 e0       	ldi	r31, 0x00	; 0
 234:	81 83       	std	Z+1, r24	; 0x01
	 matrix_data[0] = (resulte >> 8) & 0x00FF;
 236:	10 82       	st	Z, r1
	 break;
 238:	08 95       	ret
    case 0b00010001://addition
	 resulte = word_1 + word_2;
 23a:	20 91 61 00 	lds	r18, 0x0061	; 0x800061 <word_1>
 23e:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <_edata>
 242:	90 e0       	ldi	r25, 0x00	; 0
 244:	82 0f       	add	r24, r18
 246:	91 1d       	adc	r25, r1
 248:	90 93 6d 00 	sts	0x006D, r25	; 0x80006d <resulte+0x1>
 24c:	80 93 6c 00 	sts	0x006C, r24	; 0x80006c <resulte>
	 matrix_data[1] = resulte & 0x00FF;
 250:	e2 e6       	ldi	r30, 0x62	; 98
 252:	f0 e0       	ldi	r31, 0x00	; 0
 254:	81 83       	std	Z+1, r24	; 0x01
	 matrix_data[0] = (resulte >> 8) & 0x00FF;
 256:	90 83       	st	Z, r25
	 break;
 258:	08 95       	ret
    case 0b00100010://modulo
	 resulte = word_1 % word_2;
 25a:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <word_1>
 25e:	60 91 60 00 	lds	r22, 0x0060	; 0x800060 <_edata>
 262:	0e 94 9e 02 	call	0x53c	; 0x53c <__udivmodqi4>
 266:	29 2f       	mov	r18, r25
 268:	30 e0       	ldi	r19, 0x00	; 0
 26a:	30 93 6d 00 	sts	0x006D, r19	; 0x80006d <resulte+0x1>
 26e:	20 93 6c 00 	sts	0x006C, r18	; 0x80006c <resulte>
	 matrix_data[1] = resulte & 0x00FF;
 272:	e2 e6       	ldi	r30, 0x62	; 98
 274:	f0 e0       	ldi	r31, 0x00	; 0
 276:	91 83       	std	Z+1, r25	; 0x01
	 matrix_data[0] = (resulte >> 8) & 0x00FF;
 278:	10 82       	st	Z, r1
     break;
 27a:	08 95       	ret
    case 0b00100100://XOR
	 resulte = word_1 ^ word_2;
 27c:	90 91 60 00 	lds	r25, 0x0060	; 0x800060 <_edata>
 280:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <word_1>
 284:	89 27       	eor	r24, r25
 286:	28 2f       	mov	r18, r24
 288:	30 e0       	ldi	r19, 0x00	; 0
 28a:	30 93 6d 00 	sts	0x006D, r19	; 0x80006d <resulte+0x1>
 28e:	20 93 6c 00 	sts	0x006C, r18	; 0x80006c <resulte>
	 matrix_data[1] = resulte & 0x00FF;
 292:	e2 e6       	ldi	r30, 0x62	; 98
 294:	f0 e0       	ldi	r31, 0x00	; 0
 296:	81 83       	std	Z+1, r24	; 0x01
	 matrix_data[0] = (resulte >> 8) & 0x00FF;
 298:	10 82       	st	Z, r1
	 break;
 29a:	08 95       	ret
    case 0b00101000://OR
	 resulte = word_1 | word_2;
 29c:	90 91 60 00 	lds	r25, 0x0060	; 0x800060 <_edata>
 2a0:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <word_1>
 2a4:	89 2b       	or	r24, r25
 2a6:	28 2f       	mov	r18, r24
 2a8:	30 e0       	ldi	r19, 0x00	; 0
 2aa:	30 93 6d 00 	sts	0x006D, r19	; 0x80006d <resulte+0x1>
 2ae:	20 93 6c 00 	sts	0x006C, r18	; 0x80006c <resulte>
	 matrix_data[1] = resulte & 0x00FF;
 2b2:	e2 e6       	ldi	r30, 0x62	; 98
 2b4:	f0 e0       	ldi	r31, 0x00	; 0
 2b6:	81 83       	std	Z+1, r24	; 0x01
	 matrix_data[0] = (resulte >> 8) & 0x00FF;
 2b8:	10 82       	st	Z, r1
	 break;
 2ba:	08 95       	ret
    case 0b00100001://AND
	 resulte = word_1 & word_2;
 2bc:	90 91 60 00 	lds	r25, 0x0060	; 0x800060 <_edata>
 2c0:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <word_1>
 2c4:	89 23       	and	r24, r25
 2c6:	28 2f       	mov	r18, r24
 2c8:	30 e0       	ldi	r19, 0x00	; 0
 2ca:	30 93 6d 00 	sts	0x006D, r19	; 0x80006d <resulte+0x1>
 2ce:	20 93 6c 00 	sts	0x006C, r18	; 0x80006c <resulte>
	 matrix_data[1] = resulte & 0x00FF;
 2d2:	e2 e6       	ldi	r30, 0x62	; 98
 2d4:	f0 e0       	ldi	r31, 0x00	; 0
 2d6:	81 83       	std	Z+1, r24	; 0x01
	 matrix_data[0] = (resulte >> 8) & 0x00FF;
 2d8:	10 82       	st	Z, r1
	 break;
 2da:	08 95       	ret
    case 0b10000001://NOT
	 resulte = ~resulte;
 2dc:	80 91 6c 00 	lds	r24, 0x006C	; 0x80006c <resulte>
 2e0:	90 91 6d 00 	lds	r25, 0x006D	; 0x80006d <resulte+0x1>
 2e4:	80 95       	com	r24
 2e6:	90 95       	com	r25
 2e8:	90 93 6d 00 	sts	0x006D, r25	; 0x80006d <resulte+0x1>
 2ec:	80 93 6c 00 	sts	0x006C, r24	; 0x80006c <resulte>
	 matrix_data[1] = resulte & 0x00FF;
 2f0:	e2 e6       	ldi	r30, 0x62	; 98
 2f2:	f0 e0       	ldi	r31, 0x00	; 0
 2f4:	81 83       	std	Z+1, r24	; 0x01
	 matrix_data[0] = (resulte >> 8) & 0x00FF;
 2f6:	90 83       	st	Z, r25
	 break;
 2f8:	08 95       	ret
    case 0b01000001://DEL ALL
	 word_1 = 0;
 2fa:	10 92 61 00 	sts	0x0061, r1	; 0x800061 <word_1>
	 word_2 = 0;
 2fe:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <_edata>
	 resulte =0;
 302:	10 92 6d 00 	sts	0x006D, r1	; 0x80006d <resulte+0x1>
 306:	10 92 6c 00 	sts	0x006C, r1	; 0x80006c <resulte>
	 for(reset_loop=0;reset_loop<4;reset_loop++)
	  matrix_data[reset_loop] = 0;
 30a:	e2 e6       	ldi	r30, 0x62	; 98
 30c:	f0 e0       	ldi	r31, 0x00	; 0
 30e:	10 82       	st	Z, r1
 310:	11 82       	std	Z+1, r1	; 0x01
 312:	12 82       	std	Z+2, r1	; 0x02
 314:	13 82       	std	Z+3, r1	; 0x03
 316:	84 e0       	ldi	r24, 0x04	; 4
 318:	90 e0       	ldi	r25, 0x00	; 0
 31a:	90 93 6f 00 	sts	0x006F, r25	; 0x80006f <reset_loop+0x1>
 31e:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <reset_loop>
 322:	08 95       	ret

00000324 <getKeyPress>:

/***************************************************************************************************************************************************************
                                                         Function definition begins
***************************************************************************************************************************************************************/

void getKeyPress(){ // checks what key is being pressed
 324:	0f 93       	push	r16
 326:	1f 93       	push	r17
 328:	cf 93       	push	r28
 32a:	df 93       	push	r29
     for(keyRow=0;keyRow<4;keyRow++){ // scans the switch matrix(4 rows)
 32c:	10 92 69 00 	sts	0x0069, r1	; 0x800069 <keyRow+0x1>
 330:	10 92 68 00 	sts	0x0068, r1	; 0x800068 <keyRow>
 334:	80 e0       	ldi	r24, 0x00	; 0
 336:	90 e0       	ldi	r25, 0x00	; 0
    PORTD = (1<<keyRow); // sends a HIGH to one row at a time
 338:	01 e0       	ldi	r16, 0x01	; 1
 33a:	10 e0       	ldi	r17, 0x00	; 0
    columnData = (PIND & 0xF0);// reads the state of each column
	_delay_us(100);// a small delay
	if(columnData != 0){// if something is pressed columndata is bigger then zero
   	 keyData(columnData | (1<<keyRow));//goes to the data analysis function
 33c:	c8 e6       	ldi	r28, 0x68	; 104
 33e:	d0 e0       	ldi	r29, 0x00	; 0
                                                         Function definition begins
***************************************************************************************************************************************************************/

void getKeyPress(){ // checks what key is being pressed
     for(keyRow=0;keyRow<4;keyRow++){ // scans the switch matrix(4 rows)
    PORTD = (1<<keyRow); // sends a HIGH to one row at a time
 340:	98 01       	movw	r18, r16
 342:	02 c0       	rjmp	.+4      	; 0x348 <getKeyPress+0x24>
 344:	22 0f       	add	r18, r18
 346:	33 1f       	adc	r19, r19
 348:	8a 95       	dec	r24
 34a:	e2 f7       	brpl	.-8      	; 0x344 <getKeyPress+0x20>
 34c:	22 bb       	out	0x12, r18	; 18
    columnData = (PIND & 0xF0);// reads the state of each column
 34e:	80 b3       	in	r24, 0x10	; 16
 350:	80 7f       	andi	r24, 0xF0	; 240
 352:	90 e0       	ldi	r25, 0x00	; 0
 354:	90 93 71 00 	sts	0x0071, r25	; 0x800071 <columnData+0x1>
 358:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <columnData>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 35c:	8f e8       	ldi	r24, 0x8F	; 143
 35e:	91 e0       	ldi	r25, 0x01	; 1
 360:	01 97       	sbiw	r24, 0x01	; 1
 362:	f1 f7       	brne	.-4      	; 0x360 <getKeyPress+0x3c>
 364:	00 c0       	rjmp	.+0      	; 0x366 <getKeyPress+0x42>
 366:	00 00       	nop
	_delay_us(100);// a small delay
	if(columnData != 0){// if something is pressed columndata is bigger then zero
 368:	80 91 70 00 	lds	r24, 0x0070	; 0x800070 <columnData>
 36c:	90 91 71 00 	lds	r25, 0x0071	; 0x800071 <columnData+0x1>
 370:	00 97       	sbiw	r24, 0x00	; 0
 372:	89 f0       	breq	.+34     	; 0x396 <getKeyPress+0x72>
   	 keyData(columnData | (1<<keyRow));//goes to the data analysis function
 374:	98 01       	movw	r18, r16
 376:	08 80       	ld	r0, Y
 378:	02 c0       	rjmp	.+4      	; 0x37e <getKeyPress+0x5a>
 37a:	22 0f       	add	r18, r18
 37c:	33 1f       	adc	r19, r19
 37e:	0a 94       	dec	r0
 380:	e2 f7       	brpl	.-8      	; 0x37a <getKeyPress+0x56>
 382:	82 2b       	or	r24, r18
 384:	93 2b       	or	r25, r19
 386:	0e 94 b6 00 	call	0x16c	; 0x16c <keyData>
 38a:	8f e3       	ldi	r24, 0x3F	; 63
 38c:	96 e0       	ldi	r25, 0x06	; 6
 38e:	01 97       	sbiw	r24, 0x01	; 1
 390:	f1 f7       	brne	.-4      	; 0x38e <getKeyPress+0x6a>
 392:	00 c0       	rjmp	.+0      	; 0x394 <getKeyPress+0x70>
 394:	00 00       	nop
/***************************************************************************************************************************************************************
                                                         Function definition begins
***************************************************************************************************************************************************************/

void getKeyPress(){ // checks what key is being pressed
     for(keyRow=0;keyRow<4;keyRow++){ // scans the switch matrix(4 rows)
 396:	80 91 68 00 	lds	r24, 0x0068	; 0x800068 <keyRow>
 39a:	90 91 69 00 	lds	r25, 0x0069	; 0x800069 <keyRow+0x1>
 39e:	01 96       	adiw	r24, 0x01	; 1
 3a0:	90 93 69 00 	sts	0x0069, r25	; 0x800069 <keyRow+0x1>
 3a4:	80 93 68 00 	sts	0x0068, r24	; 0x800068 <keyRow>
 3a8:	84 30       	cpi	r24, 0x04	; 4
 3aa:	91 05       	cpc	r25, r1
 3ac:	4c f2       	brlt	.-110    	; 0x340 <getKeyPress+0x1c>
	if(columnData != 0){// if something is pressed columndata is bigger then zero
   	 keyData(columnData | (1<<keyRow));//goes to the data analysis function
	 _delay_us(400);//a small delay like in the LED scanning loop
   }
  }
 }
 3ae:	df 91       	pop	r29
 3b0:	cf 91       	pop	r28
 3b2:	1f 91       	pop	r17
 3b4:	0f 91       	pop	r16
 3b6:	08 95       	ret

000003b8 <pinMode>:
}


void pinMode(int position, int value)
{
        if (value == 0)
 3b8:	67 2b       	or	r22, r23
 3ba:	71 f4       	brne	.+28     	; 0x3d8 <pinMode+0x20>
          PORTA &= ~(1 << position);
 3bc:	4b b3       	in	r20, 0x1b	; 27
 3be:	21 e0       	ldi	r18, 0x01	; 1
 3c0:	30 e0       	ldi	r19, 0x00	; 0
 3c2:	b9 01       	movw	r22, r18
 3c4:	02 c0       	rjmp	.+4      	; 0x3ca <pinMode+0x12>
 3c6:	66 0f       	add	r22, r22
 3c8:	77 1f       	adc	r23, r23
 3ca:	8a 95       	dec	r24
 3cc:	e2 f7       	brpl	.-8      	; 0x3c6 <pinMode+0xe>
 3ce:	cb 01       	movw	r24, r22
 3d0:	80 95       	com	r24
 3d2:	84 23       	and	r24, r20
 3d4:	8b bb       	out	0x1b, r24	; 27
 3d6:	08 95       	ret
        else
          PORTA |= (1 << position);
 3d8:	4b b3       	in	r20, 0x1b	; 27
 3da:	21 e0       	ldi	r18, 0x01	; 1
 3dc:	30 e0       	ldi	r19, 0x00	; 0
 3de:	b9 01       	movw	r22, r18
 3e0:	02 c0       	rjmp	.+4      	; 0x3e6 <pinMode+0x2e>
 3e2:	66 0f       	add	r22, r22
 3e4:	77 1f       	adc	r23, r23
 3e6:	8a 95       	dec	r24
 3e8:	e2 f7       	brpl	.-8      	; 0x3e2 <pinMode+0x2a>
 3ea:	cb 01       	movw	r24, r22
 3ec:	84 2b       	or	r24, r20
 3ee:	8b bb       	out	0x1b, r24	; 27
 3f0:	08 95       	ret

000003f2 <shiftout>:
	 break;
    }
   }


void shiftout(unsigned char myDataOut) { // the function for sending the data to the shift register
 3f2:	0f 93       	push	r16
 3f4:	1f 93       	push	r17
 3f6:	cf 93       	push	r28
 3f8:	df 93       	push	r29
 3fa:	08 2f       	mov	r16, r24
  int i;
  int pinState=0;
  pinMode(4,0);
 3fc:	60 e0       	ldi	r22, 0x00	; 0
 3fe:	70 e0       	ldi	r23, 0x00	; 0
 400:	84 e0       	ldi	r24, 0x04	; 4
 402:	90 e0       	ldi	r25, 0x00	; 0
 404:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <pinMode>
  pinMode(6,0);
 408:	60 e0       	ldi	r22, 0x00	; 0
 40a:	70 e0       	ldi	r23, 0x00	; 0
 40c:	86 e0       	ldi	r24, 0x06	; 6
 40e:	90 e0       	ldi	r25, 0x00	; 0
 410:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <pinMode>
  for (i=7; i>=0; i--)  {
 414:	c7 e0       	ldi	r28, 0x07	; 7
 416:	d0 e0       	ldi	r29, 0x00	; 0
    pinMode(6,0);
    if ( myDataOut & (1<<i) )
 418:	10 e0       	ldi	r17, 0x00	; 0
  int i;
  int pinState=0;
  pinMode(4,0);
  pinMode(6,0);
  for (i=7; i>=0; i--)  {
    pinMode(6,0);
 41a:	60 e0       	ldi	r22, 0x00	; 0
 41c:	70 e0       	ldi	r23, 0x00	; 0
 41e:	86 e0       	ldi	r24, 0x06	; 6
 420:	90 e0       	ldi	r25, 0x00	; 0
 422:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <pinMode>
    if ( myDataOut & (1<<i) )
 426:	b8 01       	movw	r22, r16
 428:	0c 2e       	mov	r0, r28
 42a:	02 c0       	rjmp	.+4      	; 0x430 <__LOCK_REGION_LENGTH__+0x30>
 42c:	75 95       	asr	r23
 42e:	67 95       	ror	r22
 430:	0a 94       	dec	r0
 432:	e2 f7       	brpl	.-8      	; 0x42c <__LOCK_REGION_LENGTH__+0x2c>
 434:	61 70       	andi	r22, 0x01	; 1
 436:	77 27       	eor	r23, r23
      pinState = 1;
    else
      pinState = 0;
    pinMode(4,pinState);
 438:	84 e0       	ldi	r24, 0x04	; 4
 43a:	90 e0       	ldi	r25, 0x00	; 0
 43c:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <pinMode>
    pinMode(6,1);
 440:	61 e0       	ldi	r22, 0x01	; 1
 442:	70 e0       	ldi	r23, 0x00	; 0
 444:	86 e0       	ldi	r24, 0x06	; 6
 446:	90 e0       	ldi	r25, 0x00	; 0
 448:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <pinMode>
    pinMode(4,0);
 44c:	60 e0       	ldi	r22, 0x00	; 0
 44e:	70 e0       	ldi	r23, 0x00	; 0
 450:	84 e0       	ldi	r24, 0x04	; 4
 452:	90 e0       	ldi	r25, 0x00	; 0
 454:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <pinMode>
void shiftout(unsigned char myDataOut) { // the function for sending the data to the shift register
  int i;
  int pinState=0;
  pinMode(4,0);
  pinMode(6,0);
  for (i=7; i>=0; i--)  {
 458:	21 97       	sbiw	r28, 0x01	; 1
 45a:	f8 f6       	brcc	.-66     	; 0x41a <__LOCK_REGION_LENGTH__+0x1a>
      pinState = 0;
    pinMode(4,pinState);
    pinMode(6,1);
    pinMode(4,0);
  }
  pinMode(6,0);
 45c:	60 e0       	ldi	r22, 0x00	; 0
 45e:	70 e0       	ldi	r23, 0x00	; 0
 460:	86 e0       	ldi	r24, 0x06	; 6
 462:	90 e0       	ldi	r25, 0x00	; 0
 464:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <pinMode>
}
 468:	df 91       	pop	r29
 46a:	cf 91       	pop	r28
 46c:	1f 91       	pop	r17
 46e:	0f 91       	pop	r16
 470:	08 95       	ret

00000472 <main>:
unsigned char word_1=0,word_2=0;
/***************************************************************************************************************************************************************
                                                            Global Variable declaration ends
***************************************************************************************************************************************************************/
int main(void){
 DDRD = 0x0F;//pins PD0-PD3 outputs and pins PD4-PD7 inputs
 472:	8f e0       	ldi	r24, 0x0F	; 15
 474:	81 bb       	out	0x11, r24	; 17
 DDRA = 0xFF;//pins PA0-PA7 as input
 476:	8f ef       	ldi	r24, 0xFF	; 255
 478:	8a bb       	out	0x1a, r24	; 26
  while(1){// keeps the program running all the time

   for(ledRow=0;ledRow<4;ledRow++){// this is the loop for scanning the LED display
	 time_to_check ++;//counts the time until the next key press check(to prevent flickering of the matrix)
	 PORTA = 1<<ledRow;//sets only one pin from PD0-PD3 HIGH
 47a:	c1 e0       	ldi	r28, 0x01	; 1
 47c:	d0 e0       	ldi	r29, 0x00	; 0
 47e:	0c 2f       	mov	r16, r28
 480:	1d 2f       	mov	r17, r29
int main(void){
 DDRD = 0x0F;//pins PD0-PD3 outputs and pins PD4-PD7 inputs
 DDRA = 0xFF;//pins PA0-PA7 as input
  while(1){// keeps the program running all the time

   for(ledRow=0;ledRow<4;ledRow++){// this is the loop for scanning the LED display
 482:	10 92 6b 00 	sts	0x006B, r1	; 0x80006b <ledRow+0x1>
 486:	10 92 6a 00 	sts	0x006A, r1	; 0x80006a <ledRow>
 48a:	80 e0       	ldi	r24, 0x00	; 0
 48c:	90 e0       	ldi	r25, 0x00	; 0
	 time_to_check ++;//counts the time until the next key press check(to prevent flickering of the matrix)
 48e:	20 91 66 00 	lds	r18, 0x0066	; 0x800066 <time_to_check>
 492:	30 91 67 00 	lds	r19, 0x0067	; 0x800067 <time_to_check+0x1>
 496:	2f 5f       	subi	r18, 0xFF	; 255
 498:	3f 4f       	sbci	r19, 0xFF	; 255
 49a:	30 93 67 00 	sts	0x0067, r19	; 0x800067 <time_to_check+0x1>
 49e:	20 93 66 00 	sts	0x0066, r18	; 0x800066 <time_to_check>
	 PORTA = 1<<ledRow;//sets only one pin from PD0-PD3 HIGH
 4a2:	9e 01       	movw	r18, r28
 4a4:	02 c0       	rjmp	.+4      	; 0x4aa <main+0x38>
 4a6:	22 0f       	add	r18, r18
 4a8:	33 1f       	adc	r19, r19
 4aa:	8a 95       	dec	r24
 4ac:	e2 f7       	brpl	.-8      	; 0x4a6 <main+0x34>
 4ae:	2b bb       	out	0x1b, r18	; 27
	 pinMode(5,0);//latch off
 4b0:	60 e0       	ldi	r22, 0x00	; 0
 4b2:	70 e0       	ldi	r23, 0x00	; 0
 4b4:	85 e0       	ldi	r24, 0x05	; 5
 4b6:	90 e0       	ldi	r25, 0x00	; 0
 4b8:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <pinMode>
	 shiftout(matrix_data[ledRow]);//writes the data to the shift register
 4bc:	e0 91 6a 00 	lds	r30, 0x006A	; 0x80006a <ledRow>
 4c0:	f0 91 6b 00 	lds	r31, 0x006B	; 0x80006b <ledRow+0x1>
 4c4:	ee 59       	subi	r30, 0x9E	; 158
 4c6:	ff 4f       	sbci	r31, 0xFF	; 255
 4c8:	80 81       	ld	r24, Z
 4ca:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <shiftout>
	 pinMode(5,1);//latch on
 4ce:	60 2f       	mov	r22, r16
 4d0:	71 2f       	mov	r23, r17
 4d2:	85 e0       	ldi	r24, 0x05	; 5
 4d4:	90 e0       	ldi	r25, 0x00	; 0
 4d6:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <pinMode>
	 if(time_to_check == 125){//looks when the time is right to check for a key press
 4da:	80 91 66 00 	lds	r24, 0x0066	; 0x800066 <time_to_check>
 4de:	90 91 67 00 	lds	r25, 0x0067	; 0x800067 <time_to_check+0x1>
 4e2:	8d 37       	cpi	r24, 0x7D	; 125
 4e4:	91 05       	cpc	r25, r1
 4e6:	39 f4       	brne	.+14     	; 0x4f6 <main+0x84>
	  getKeyPress();// goes to the key press function
 4e8:	0e 94 92 01 	call	0x324	; 0x324 <getKeyPress>
	  time_to_check =0;//resets the "counter"
 4ec:	10 92 67 00 	sts	0x0067, r1	; 0x800067 <time_to_check+0x1>
 4f0:	10 92 66 00 	sts	0x0066, r1	; 0x800066 <time_to_check>
 4f4:	06 c0       	rjmp	.+12     	; 0x502 <main+0x90>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 4f6:	8f e9       	ldi	r24, 0x9F	; 159
 4f8:	9f e0       	ldi	r25, 0x0F	; 15
 4fa:	01 97       	sbiw	r24, 0x01	; 1
 4fc:	f1 f7       	brne	.-4      	; 0x4fa <main+0x88>
 4fe:	00 c0       	rjmp	.+0      	; 0x500 <main+0x8e>
 500:	00 00       	nop
	  }
     else
	  _delay_ms(1);// a delay for each LED row
	 pinMode(5,0);//latch off
 502:	60 e0       	ldi	r22, 0x00	; 0
 504:	70 e0       	ldi	r23, 0x00	; 0
 506:	85 e0       	ldi	r24, 0x05	; 5
 508:	90 e0       	ldi	r25, 0x00	; 0
 50a:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <pinMode>
	 shiftout(0x00);// sets the shift registers outputs to low
 50e:	80 e0       	ldi	r24, 0x00	; 0
 510:	0e 94 f9 01 	call	0x3f2	; 0x3f2 <shiftout>
	 pinMode(5,1);//latch on
 514:	60 2f       	mov	r22, r16
 516:	71 2f       	mov	r23, r17
 518:	85 e0       	ldi	r24, 0x05	; 5
 51a:	90 e0       	ldi	r25, 0x00	; 0
 51c:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <pinMode>
int main(void){
 DDRD = 0x0F;//pins PD0-PD3 outputs and pins PD4-PD7 inputs
 DDRA = 0xFF;//pins PA0-PA7 as input
  while(1){// keeps the program running all the time

   for(ledRow=0;ledRow<4;ledRow++){// this is the loop for scanning the LED display
 520:	80 91 6a 00 	lds	r24, 0x006A	; 0x80006a <ledRow>
 524:	90 91 6b 00 	lds	r25, 0x006B	; 0x80006b <ledRow+0x1>
 528:	01 96       	adiw	r24, 0x01	; 1
 52a:	90 93 6b 00 	sts	0x006B, r25	; 0x80006b <ledRow+0x1>
 52e:	80 93 6a 00 	sts	0x006A, r24	; 0x80006a <ledRow>
 532:	84 30       	cpi	r24, 0x04	; 4
 534:	91 05       	cpc	r25, r1
 536:	0c f4       	brge	.+2      	; 0x53a <main+0xc8>
 538:	aa cf       	rjmp	.-172    	; 0x48e <main+0x1c>
 53a:	a3 cf       	rjmp	.-186    	; 0x482 <main+0x10>

0000053c <__udivmodqi4>:
 53c:	99 1b       	sub	r25, r25
 53e:	79 e0       	ldi	r23, 0x09	; 9
 540:	04 c0       	rjmp	.+8      	; 0x54a <__udivmodqi4_ep>

00000542 <__udivmodqi4_loop>:
 542:	99 1f       	adc	r25, r25
 544:	96 17       	cp	r25, r22
 546:	08 f0       	brcs	.+2      	; 0x54a <__udivmodqi4_ep>
 548:	96 1b       	sub	r25, r22

0000054a <__udivmodqi4_ep>:
 54a:	88 1f       	adc	r24, r24
 54c:	7a 95       	dec	r23
 54e:	c9 f7       	brne	.-14     	; 0x542 <__udivmodqi4_loop>
 550:	80 95       	com	r24
 552:	08 95       	ret

00000554 <__tablejump2__>:
 554:	ee 0f       	add	r30, r30
 556:	ff 1f       	adc	r31, r31
 558:	05 90       	lpm	r0, Z+
 55a:	f4 91       	lpm	r31, Z
 55c:	e0 2d       	mov	r30, r0
 55e:	09 94       	ijmp

00000560 <_exit>:
 560:	f8 94       	cli

00000562 <__stop_program>:
 562:	ff cf       	rjmp	.-2      	; 0x562 <__stop_program>
